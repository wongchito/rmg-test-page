{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["getRFFHelper","char","charForm","a","document","fonts","load","then","f","querySelectorAll","filter","el","id","sheet","cssRules","rule","cssText","includes","unicodeRange","getRenderedFontFace","Promise","all","catch","console","warn","readBlobAsDataURL","blob","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","fetch","response","text","csstext","s","createElement","type","innerText","head","append","txt","Set","map","innerHTML","join","replace","rules","querySelector","remove","concat","match","uri"],"mappings":"6NAKMA,EAAY,uCAAG,WAAOC,EAAcC,GAArB,SAAAC,EAAA,+EACjBC,SAASC,MAAMC,KAAK,mBAAqBJ,EAAUD,GAAMM,MAAK,SAAAC,GAE1D,OAAO,YACC,YAAIJ,SAASK,iBAAiB,UAAUC,QAAO,SAAAC,GAAE,MAAc,gBAAVA,EAAGC,MAAsB,GAAGC,MAChFC,UAEJJ,QAAO,SAAAK,GAAI,OAAIA,EAAKC,QAAQC,SAAS,cAAgBf,MACrDQ,QAAO,SAAAK,GAAI,OAAIA,EAAKC,QAAQC,SAAST,EAAE,GAAGU,iBAAe,GAAGF,YARpD,2CAAH,wDAeZG,EAAmB,uCAAG,WAAOlB,GAAP,SAAAE,EAAA,yDACX,WAATF,EADoB,yCAEbmB,QAAQC,IAAI,CAACrB,EAAaC,EAAM,SAFnB,gCAIjBmB,QAAQC,IAAI,CAACrB,EAAaC,EAAM,QAAQqB,OAAM,kBACjDF,QAAQC,IAAI,CAACrB,EAAaC,EAAM,QAAQqB,OAAM,kBAC1CF,QAAQC,IAAI,CAACrB,EAAaC,EAAM,MAAOD,EAAaC,EAAM,QAAQqB,OAAM,kBACpEF,QAAQC,IAAI,CAACrB,EAAaC,EAAM,QAAQqB,OAAM,WAE1C,OADAC,QAAQC,KAAKvB,EAAO,eACb,gBATC,2CAAH,sDAoBnBwB,EAAoB,SAACC,GAAD,OACtB,IAAIN,SAAQ,SAACO,GACT,IAAIC,EAAS,IAAIC,WACjBD,EAAOE,UAAY,kBAAMH,EAAQC,EAAOG,SACxCH,EAAOI,cAAcN,OAOhBO,EAAoB,SAACC,GAAD,OAC7BC,MACI,kIAEC5B,MAAK,SAAA6B,GAAQ,OAAIA,EAASC,UAC1B9B,KAJL,uCAIU,WAAM+B,GAAN,iBAAAnC,EAAA,6DACEoC,EAAInC,SAASoC,cAAc,UAC7BC,KAAO,WACTF,EAAE3B,GAAK,cACP2B,EAAEG,UAAYJ,EACdlC,SAASuC,KAAKC,OAAOL,GAEjBM,EAPF,YAQK,IAAIC,IACH,YAAKZ,EAAMzB,iBAAiB,kBACvBsC,KAAI,SAAApC,GAAE,OAAIA,EAAGqC,aACbC,KAAK,IACLC,QAAQ,YAAa,MAZhC,kBAgBK9B,QAAQC,IAAIwB,EAAIE,IAAI5B,IAAsBZ,MAAK,SAAA4C,GAAU,IAAD,IAE3D,OADA,UAAA/C,SAASgD,cAAc,4BAAvB,SAA6CC,SACtC,YAAI,IAAIP,KAAK,MAAgBQ,OAAjB,oBAA2BH,MAASJ,KAAI,SAAAhC,GAAI,OAC3DoB,MAAMpB,EAAKwC,MAAM,0BAA2B,IACvChD,MAAK,SAAA6B,GAAQ,OAAIA,EAASV,UAC1BnB,KAAKkB,GACLlB,MAAK,SAAAiD,GAAG,OAAIzC,EAAKmC,QAAQ,yBAAb,oBAAoDM,EAApD,mBAtBvB,2CAJV","file":"static/js/panelPreviewMTR.87c1a705.chunk.js","sourcesContent":["/**\n * Helper function for filtering out the `CSSFontFaceRule` which renders the input character by matching character form and unicode range.\n * @param char string with one Chinese character\n * @param charForm code indicating country-variant Noto Serif font\n */\nconst getRFFHelper = async (char: string, charForm: 'SC' | 'TC' | 'JP' | 'KR'): Promise<string> =>\n    document.fonts.load('80px Noto Serif ' + charForm, char).then(f => {\n        // console.log(char, f);\n        return [\n            ...([...document.querySelectorAll('style')].filter(el => el.id === 'googlefonts')[0].sheet as CSSStyleSheet)\n                .cssRules,\n        ]\n            .filter(rule => rule.cssText.includes('Noto Serif ' + charForm))\n            .filter(rule => rule.cssText.includes(f[0].unicodeRange))[0].cssText;\n    });\n\n/**\n * Get `cssText` of `CSSFontFaceRule` which renders the input character.\n * @param char string with one Chinese character\n */\nconst getRenderedFontFace = async (char: string): Promise<string[]> => {\n    if (char === 'é—¨') {\n        return Promise.all([getRFFHelper(char, 'SC')]);\n    }\n    return Promise.all([getRFFHelper(char, 'KR')]).catch(() =>\n        Promise.all([getRFFHelper(char, 'JP')]).catch(() =>\n            Promise.all([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]).catch(() =>\n                Promise.all([getRFFHelper(char, 'SC')]).catch(() => {\n                    console.warn(char + ': not found');\n                    return [];\n                })\n            )\n        )\n    );\n};\n\n/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob) =>\n    new Promise((resolve: (value: string) => void) => {\n        let reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n\n/**\n * Get `CSSFontFaceRule` whose source is Base64 URL for all Chinese characters in a `SVGSVGElement`.\n * @param svgEl `SVGSVGElement` to be exported\n */\nexport const getBase64FontFace = (svgEl: SVGSVGElement) =>\n    fetch(\n        'https://fonts.googleapis.com/css?family=Noto+Serif+KR:600|Noto+Serif+JP:600|Noto+Serif+TC:600|Noto+Serif+SC:600%26display=swap'\n    )\n        .then(response => response.text())\n        .then(async csstext => {\n            let s = document.createElement('style');\n            s.type = 'text/css';\n            s.id = 'googlefonts';\n            s.innerText = csstext;\n            document.head.append(s);\n\n            let txt = [\n                ...new Set(\n                    [...(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)]\n                        .map(el => el.innerHTML)\n                        .join('')\n                        .replace(/[\\d\\w\\s]/g, '')\n                ),\n            ];\n\n            return Promise.all(txt.map(getRenderedFontFace)).then(rules => {\n                document.querySelector('style#googlefonts')?.remove();\n                return [...new Set(([] as string[]).concat(...rules))].map(rule =>\n                    fetch(rule.match(/https:[\\w:/.-]+.woff2/g)![0])\n                        .then(response => response.blob())\n                        .then(readBlobAsDataURL)\n                        .then(uri => rule.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${uri}'); `))\n                );\n            });\n        });\n"],"sourceRoot":""}