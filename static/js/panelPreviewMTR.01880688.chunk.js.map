{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["getRFFHelper","char","charForm","a","document","fonts","load","then","f","ur","unicodeRange","querySelectorAll","filter","el","id","sheet","cssRules","rule","cssText","includes","getRenderedFontFace","Promise","all","catch","readBlobAsDataURL","blob","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","fetch","response","text","csstext","s","createElement","type","innerText","head","append","txt","Set","map","innerHTML","join","replace","rules","concat","match","uri"],"mappings":"6NAKMA,EAAY,uCAAG,WAAOC,EAAcC,GAArB,SAAAC,EAAA,+EACjBC,SAASC,MAAMC,KAAK,mBAAqBJ,EAAUD,GAAMM,MAAK,SAAAC,GAC1D,IAAIC,EAAKD,EAAE,GAAGE,aACd,OAAO,YACC,YAAIN,SAASO,iBAAiB,UAAUC,QAAO,SAAAC,GAAE,MAAc,gBAAVA,EAAGC,MAAsB,GAAGC,MAChFC,UAEJJ,QAAO,SAAAK,GAAI,OAAIA,EAAKC,QAAQC,SAAS,cAAgBjB,MACrDU,QAAO,SAAAK,GAAI,OAAIA,EAAKC,QAAQC,SAASV,MAAK,GAAGS,YARrC,2CAAH,wDAeZE,EAAmB,uCAAG,WAAOnB,GAAP,SAAAE,EAAA,yDACX,WAATF,EADoB,yCAEboB,QAAQC,IAAI,CAACtB,EAAaC,EAAM,SAFnB,gCAIjBoB,QAAQC,IAAI,CAACtB,EAAaC,EAAM,QAAQsB,OAAM,kBACjDF,QAAQC,IAAI,CAACtB,EAAaC,EAAM,QAAQsB,OAAM,kBAC1CF,QAAQC,IAAI,CAACtB,EAAaC,EAAM,MAAOD,EAAaC,EAAM,QAAQsB,OAAM,kBACpEF,QAAQC,IAAI,CAACtB,EAAaC,EAAM,kBAPpB,2CAAH,sDAiBnBuB,EAAoB,SAACC,GAAD,OACtB,IAAIJ,SAAQ,SAACK,GACT,IAAIC,EAAS,IAAIC,WACjBD,EAAOE,UAAY,kBAAMH,EAAQC,EAAOG,SACxCH,EAAOI,cAAcN,OAOhBO,EAAoB,SAACC,GAAD,OAC7BC,MACI,kIAEC3B,MAAK,SAAA4B,GAAQ,OAAIA,EAASC,UAC1B7B,KAJL,uCAIU,WAAM8B,GAAN,iBAAAlC,EAAA,6DACEmC,EAAIlC,SAASmC,cAAc,UAC7BC,KAAO,WACTF,EAAExB,GAAK,cACPwB,EAAEG,UAAYJ,EACdjC,SAASsC,KAAKC,OAAOL,GAEjBM,EAPF,YAQK,IAAIC,IACH,YAAKZ,EAAMtB,iBAAiB,kBACvBmC,KAAI,SAAAjC,GAAE,OAAIA,EAAGkC,aACbC,KAAK,IACLC,QAAQ,UAAW,MAZ9B,kBAgBK5B,QAAQC,IAAIsB,EAAIE,IAAI1B,IACtBb,MAAK,SAAA2C,GAAK,aAAK,MAAgBC,OAAjB,oBAA2BD,OACzC3C,MAAK,SAAA2C,GAAK,mBAAQ,IAAIL,IAAIK,OAC1B3C,MAAK,SAAA2C,GAAK,OACPA,EAAMJ,KAAI,SAAA7B,GAAI,OACViB,MAAMjB,EAAKmC,MAAM,0BAA2B,IACvC7C,MAAK,SAAA4B,GAAQ,OAAIA,EAASV,UAC1BlB,KAAKiB,GACLjB,MAAK,SAAA8C,GAAG,OAAIpC,EAAKgC,QAAQ,yBAAb,oBAAoDI,EAApD,mBAxB3B,2CAJV","file":"static/js/panelPreviewMTR.01880688.chunk.js","sourcesContent":["/**\n * Helper function for filtering out the `CSSFontFaceRule` which renders the input character by matching character form and unicode range.\n * @param char string with one Chinese character\n * @param charForm code indicating country-variant Noto Serif font\n */\nconst getRFFHelper = async (char: string, charForm: 'SC' | 'TC' | 'JP' | 'KR'): Promise<string> =>\n    document.fonts.load('80px Noto Serif ' + charForm, char).then(f => {\n        let ur = f[0].unicodeRange;\n        return [\n            ...([...document.querySelectorAll('style')].filter(el => el.id === 'googlefonts')[0].sheet as CSSStyleSheet)\n                .cssRules,\n        ]\n            .filter(rule => rule.cssText.includes('Noto Serif ' + charForm))\n            .filter(rule => rule.cssText.includes(ur))[0].cssText;\n    });\n\n/**\n * Get `cssText` of `CSSFontFaceRule` which renders the input character.\n * @param char string with one Chinese character\n */\nconst getRenderedFontFace = async (char: string): Promise<string[]> => {\n    if (char === 'é—¨') {\n        return Promise.all([getRFFHelper(char, 'SC')]);\n    }\n    return Promise.all([getRFFHelper(char, 'KR')]).catch(() =>\n        Promise.all([getRFFHelper(char, 'JP')]).catch(() =>\n            Promise.all([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]).catch(() =>\n                Promise.all([getRFFHelper(char, 'SC')])\n            )\n        )\n    );\n};\n\n/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob) =>\n    new Promise((resolve: (value: string) => void) => {\n        let reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n\n/**\n * Get `CSSFontFaceRule` whose source is Base64 URL for all Chinese characters in a `SVGSVGElement`.\n * @param svgEl `SVGSVGElement` to be exported\n */\nexport const getBase64FontFace = (svgEl: SVGSVGElement) =>\n    fetch(\n        'https://fonts.googleapis.com/css?family=Noto+Serif+KR:600|Noto+Serif+JP:600|Noto+Serif+TC:600|Noto+Serif+SC:600%26display=swap'\n    )\n        .then(response => response.text())\n        .then(async csstext => {\n            let s = document.createElement('style');\n            s.type = 'text/css';\n            s.id = 'googlefonts';\n            s.innerText = csstext;\n            document.head.append(s);\n\n            let txt = [\n                ...new Set(\n                    [...(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)]\n                        .map(el => el.innerHTML)\n                        .join('')\n                        .replace(/[\\d\\s]/g, '')\n                ),\n            ];\n\n            return Promise.all(txt.map(getRenderedFontFace))\n                .then(rules => ([] as string[]).concat(...rules))\n                .then(rules => [...new Set(rules)])\n                .then(rules =>\n                    rules.map(rule =>\n                        fetch(rule.match(/https:[\\w:/.-]+.woff2/g)![0])\n                            .then(response => response.blob())\n                            .then(readBlobAsDataURL)\n                            .then(uri => rule.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${uri}'); `))\n                    )\n                );\n        });\n"],"sourceRoot":""}