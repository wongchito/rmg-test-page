{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["getRFFHelper","char","charForm","a","document","fonts","load","then","f","querySelectorAll","filter","el","id","sheet","cssRules","rule","cssText","includes","unicodeRange","getRenderedFontFace","Promise","all","catch","allSettled","results","rules","reduce","acc","res","status","concat","value","console","log","length","warn","readBlobAsDataURL","blob","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","fetch","response","text","csstext","s","createElement","type","textContent","head","append","txt","Set","map","innerHTML","join","replace","querySelector","remove","match","uri"],"mappings":"6NAKMA,EAAY,uCAAG,WAAOC,EAAcC,GAArB,SAAAC,EAAA,+EACjBC,SAASC,MAAMC,KAAK,mBAAqBJ,EAAUD,GAAMM,MAAK,SAACC,GAE3D,OAAO,YACC,YAAIJ,SAASK,iBAAiB,UAAUC,QAAO,SAACC,GAAD,MAAkB,gBAAVA,EAAGC,MAAsB,GAC/EC,MAAwBC,UAE5BJ,QAAO,SAACK,GAAD,OAAUA,EAAKC,QAAQC,SAAS,cAAgBf,MACvDQ,QAAO,SAACK,GAAD,OAAUA,EAAKC,QAAQC,SAAST,EAAE,GAAGU,iBAAe,GAAGF,YARtD,2CAAH,wDAeZG,EAAmB,uCAAG,WAAOlB,GAAP,SAAAE,EAAA,yDACX,WAATF,EADoB,yCAEbmB,QAAQC,IAAI,CAACrB,EAAaC,EAAM,SAFnB,gCAIjBmB,QAAQC,IAAI,CAACrB,EAAaC,EAAM,QAAQqB,OAAM,kBACjDF,QAAQC,IAAI,CAACrB,EAAaC,EAAM,QAAQqB,MAAxC,sBAA8C,8BAAAnB,EAAA,sEAEpBiB,QAAQG,WAAW,CAACvB,EAAaC,EAAM,MAAOD,EAAaC,EAAM,QAF7C,cAEpCuB,EAFoC,OAGtCC,EAAQD,EAAQE,QAChB,SAACC,EAAKC,GAAN,MAA8B,cAAfA,EAAIC,OAAyBF,EAAIG,OAAOF,EAAIG,OAASJ,IACpE,IAEJK,QAAQC,IAAIR,GACPA,EAAMS,QAAQF,QAAQG,KAAKlC,EAAO,eARG,kBASnCwB,GATmC,gDAL1B,2CAAH,sDAiCnBW,EAAoB,SAACC,GAAD,OACtB,IAAIjB,SAAQ,SAACkB,GACT,IAAIC,EAAS,IAAIC,WACjBD,EAAOE,UAAY,kBAAMH,EAAQC,EAAOG,SACxCH,EAAOI,cAAcN,OAOhBO,EAAoB,SAACC,GAAD,OAC7BC,MACI,kIAECvC,MAAK,SAACwC,GAAD,OAAcA,EAASC,UAC5BzC,KAJL,uCAIU,WAAO0C,GAAP,iBAAA9C,EAAA,6DACE+C,EAAI9C,SAAS+C,cAAc,UAC7BC,KAAO,WACTF,EAAEtC,GAAK,cACPsC,EAAEG,YAAcJ,EAChB7C,SAASkD,KAAKC,OAAOL,GAEjBM,EAPF,YAQK,IAAIC,IACH,YAAKZ,EAAMpC,iBAAiB,kBACvBiD,KAAI,SAAC/C,GAAD,OAAQA,EAAGgD,aACfC,KAAK,IACLC,QAAQ,YAAa,MAZhC,kBAgBKzC,QAAQC,IAAImC,EAAIE,IAAIvC,IAAsBZ,MAAK,SAACkB,GAAW,IAAD,IAE7D,OADA,UAAArB,SAAS0D,cAAc,4BAAvB,SAA6CC,SACtC,YAAI,IAAIN,KAAK,MAAgB3B,OAAjB,oBAA2BL,MAASiC,KAAI,SAAC3C,GAAD,OACvD+B,MAAM/B,EAAKiD,MAAM,0BAA2B,IACvCzD,MAAK,SAACwC,GAAD,OAAcA,EAASV,UAC5B9B,KAAK6B,GACL7B,MAAK,SAAC0D,GAAD,OAASlD,EAAK8C,QAAQ,yBAAb,oBAAoDI,EAApD,mBAtBzB,2CAJV","file":"static/js/panelPreviewMTR.d1dd8cf4.chunk.js","sourcesContent":["/**\n * Helper function for filtering out the `CSSFontFaceRule` which renders the input character by matching character form and unicode range.\n * @param char string with one Chinese character\n * @param charForm code indicating country-variant Noto Serif font\n */\nconst getRFFHelper = async (char: string, charForm: 'SC' | 'TC' | 'JP' | 'KR'): Promise<string> =>\n    document.fonts.load('80px Noto Serif ' + charForm, char).then((f) => {\n        // console.log(char, f);\n        return [\n            ...([...document.querySelectorAll('style')].filter((el) => el.id === 'googlefonts')[0]\n                .sheet as CSSStyleSheet).cssRules,\n        ]\n            .filter((rule) => rule.cssText.includes('Noto Serif ' + charForm))\n            .filter((rule) => rule.cssText.includes(f[0].unicodeRange))[0].cssText;\n    });\n\n/**\n * Get `cssText` of `CSSFontFaceRule` which renders the input character.\n * @param char string with one Chinese character\n */\nconst getRenderedFontFace = async (char: string): Promise<string[]> => {\n    if (char === 'é—¨') {\n        return Promise.all([getRFFHelper(char, 'SC')]);\n    }\n    return Promise.all([getRFFHelper(char, 'KR')]).catch(() =>\n        Promise.all([getRFFHelper(char, 'JP')]).catch(async () => {\n            // Render with TC and SC together due to weird response\n            const results = await Promise.allSettled([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]);\n            let rules = results.reduce(\n                (acc, res) => (res.status === 'fulfilled' ? acc.concat(res.value) : acc),\n                [] as string[]\n            );\n            console.log(rules);\n            if (!rules.length) console.warn(char + ': not found');\n            return rules;\n        })\n    );\n    // return Promise.all([getRFFHelper(char, 'KR')]).catch(() =>\n    //     Promise.all([getRFFHelper(char, 'JP')]).catch(() =>\n    //         Promise.all([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]).catch(() =>\n    //             Promise.all([getRFFHelper(char, 'SC')]).catch(() => {\n    //                 console.warn(char + ': not found');\n    //                 return [];\n    //             })\n    //         )\n    //     )\n    // );\n};\n\n/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob) =>\n    new Promise((resolve: (value: string) => void) => {\n        let reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n\n/**\n * Get `CSSFontFaceRule` whose source is Base64 URL for all Chinese characters in a `SVGSVGElement`.\n * @param svgEl `SVGSVGElement` to be exported\n */\nexport const getBase64FontFace = (svgEl: SVGSVGElement) =>\n    fetch(\n        'https://fonts.googleapis.com/css?family=Noto+Serif+KR:600|Noto+Serif+JP:600|Noto+Serif+TC:600|Noto+Serif+SC:600%26display=swap'\n    )\n        .then((response) => response.text())\n        .then(async (csstext) => {\n            let s = document.createElement('style');\n            s.type = 'text/css';\n            s.id = 'googlefonts';\n            s.textContent = csstext;\n            document.head.append(s);\n\n            let txt = [\n                ...new Set(\n                    [...(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)]\n                        .map((el) => el.innerHTML)\n                        .join('')\n                        .replace(/[\\d\\w\\s]/g, '')\n                ),\n            ];\n\n            return Promise.all(txt.map(getRenderedFontFace)).then((rules) => {\n                document.querySelector('style#googlefonts')?.remove();\n                return [...new Set(([] as string[]).concat(...rules))].map((rule) =>\n                    fetch(rule.match(/https:[\\w:/.-]+.woff2/g)![0])\n                        .then((response) => response.blob())\n                        .then(readBlobAsDataURL)\n                        .then((uri) => rule.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${uri}'); `))\n                );\n            });\n        });\n"],"sourceRoot":""}