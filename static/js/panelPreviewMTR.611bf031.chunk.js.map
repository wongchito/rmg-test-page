{"version":3,"sources":["panels/save/export-diag/mtr-helper.ts"],"names":["getRFFHelper","char","charForm","a","document","fonts","load","then","f","ur","unicodeRange","Array","from","querySelectorAll","filter","el","id","sheet","cssRules","rule","cssText","includes","getRenderedFontFace","Promise","all","catch","readBlobAsDataURL","blob","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","fetch","response","text","csstext","s","createElement","type","innerText","head","append","txt","Set","map","innerHTML","join","replace","rules","concat","match","uri"],"mappings":"6NAKMA,EAAY,uCAAG,WAAOC,EAAcC,GAArB,SAAAC,EAAA,+EAEVC,SAASC,MAAMC,KAAK,mBAAqBJ,EAAUD,GAAMM,MAAK,SAAAC,GACjE,IAAIC,EAAKD,EAAE,GAAGE,aACd,OAAOC,MAAMC,KACRD,MAAMC,KAAKR,SAASS,iBAAiB,UAAUC,QAAO,SAAAC,GAAE,MAAc,gBAAVA,EAAGC,MAAsB,GACjFC,MAAwBC,UAE5BJ,QAAO,SAAAK,GAAI,OAAIA,EAAKC,QAAQC,SAAS,cAAgBnB,MACrDY,QAAO,SAAAK,GAAI,OAAIA,EAAKC,QAAQC,SAASZ,MAAK,GAAGW,YATrC,2CAAH,wDAiBZE,EAAmB,uCAAG,WAAOrB,GAAP,SAAAE,EAAA,yDACX,WAATF,EADoB,yCAEbsB,QAAQC,IAAI,CAACxB,EAAaC,EAAM,SAFnB,gCAIjBsB,QAAQC,IAAI,CAACxB,EAAaC,EAAM,QAAQwB,OAAM,WACjD,OAAOF,QAAQC,IAAI,CAACxB,EAAaC,EAAM,QAAQwB,OAAM,WACjD,OAAOF,QAAQC,IAAI,CAACxB,EAAaC,EAAM,MAAOD,EAAaC,EAAM,QAAQwB,OAAM,WAC3E,OAAOF,QAAQC,IAAI,CAACxB,EAAaC,EAAM,kBAP3B,2CAAH,sDAiBnByB,EAAoB,SAACC,GACvB,OAAO,IAAIJ,SAAQ,SAACK,GAChB,IAAIC,EAAS,IAAIC,WACjBD,EAAOE,UAAY,WACfH,EAAQC,EAAOG,SAEnBH,EAAOI,cAAcN,OAQhBO,EAAiB,uCAAG,WAAOC,GAAP,SAAAhC,EAAA,4DAEzB,iIAFyB,kBAGtBiC,MADH,kIAEC7B,MAAK,SAAA8B,GAAQ,OAAIA,EAASC,UAC1B/B,KAFE,uCAEG,WAAMgC,GAAN,iBAAApC,EAAA,6DACEqC,EAAIpC,SAASqC,cAAc,UAC7BC,KAAO,WACTF,EAAExB,GAAK,cACPwB,EAAEG,UAAYJ,EACdnC,SAASwC,KAAKC,OAAOL,GAEjBM,EAAMnC,MAAMC,KACZ,IAAImC,IACApC,MAAMC,KAAKuB,EAAMtB,iBAAiB,kBAC7BmC,KAAI,SAAAjC,GAAE,OAAIA,EAAGkC,aACbC,KAAK,IACLC,QAAQ,UAAW,MAZ9B,kBAgBK5B,QAAQC,IAAIsB,EAAIE,IAAI1B,IACtBf,MAAK,SAAA6C,GAAK,aAAK,MAAgBC,OAAjB,oBAA2BD,OACzC7C,MAAK,SAAA6C,GAAK,mBAAQ,IAAIL,IAAIK,OAC1B7C,MAAK,SAAA6C,GACF,OAAOA,EAAMJ,IAAN,uCAAU,WAAM7B,GAAN,SAAAhB,EAAA,+EACNiC,MAAMjB,EAAKmC,MAAM,0BAA2B,IAC9C/C,MAAK,SAAA8B,GAAQ,OAAIA,EAASV,UAC1BpB,KAAKmB,GACLnB,MAAK,SAAAgD,GAAG,OAAIpC,EAAKgC,QAAQ,yBAAb,oBAAoDI,EAApD,aAJJ,2CAAV,2DApBb,2CAFH,wDAHsB,2CAAH","file":"static/js/panelPreviewMTR.611bf031.chunk.js","sourcesContent":["/**\n * Helper function for filtering out the `CSSFontFaceRule` which renders the input character by matching character form and unicode range.\n * @param char string with one Chinese character\n * @param charForm code indicating country-variant Noto Serif font\n */\nconst getRFFHelper = async (char: string, charForm: 'SC' | 'TC' | 'JP' | 'KR'): Promise<string> => {\n    // console.log(char, charForm)\n    return document.fonts.load('80px Noto Serif ' + charForm, char).then(f => {\n        let ur = f[0].unicodeRange;\n        return Array.from(\n            (Array.from(document.querySelectorAll('style')).filter(el => el.id === 'googlefonts')[0]\n                .sheet as CSSStyleSheet).cssRules\n        )\n            .filter(rule => rule.cssText.includes('Noto Serif ' + charForm))\n            .filter(rule => rule.cssText.includes(ur))[0].cssText;\n    });\n};\n\n/**\n * Get `cssText` of `CSSFontFaceRule` which renders the input character.\n * @param char string with one Chinese character\n */\nconst getRenderedFontFace = async (char: string): Promise<string[]> => {\n    if (char === 'é—¨') {\n        return Promise.all([getRFFHelper(char, 'SC')]);\n    }\n    return Promise.all([getRFFHelper(char, 'KR')]).catch(() => {\n        return Promise.all([getRFFHelper(char, 'JP')]).catch(() => {\n            return Promise.all([getRFFHelper(char, 'TC'), getRFFHelper(char, 'SC')]).catch(() => {\n                return Promise.all([getRFFHelper(char, 'SC')]);\n            });\n        });\n    });\n};\n\n/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob) => {\n    return new Promise((resolve: (value: string) => void) => {\n        let reader = new FileReader();\n        reader.onloadend = () => {\n            resolve(reader.result as string);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\n\n/**\n * Get `CSSFontFaceRule` whose source is Base64 URL for all Chinese characters in a `SVGSVGElement`.\n * @param svgEl `SVGSVGElement` to be exported\n */\nexport const getBase64FontFace = async (svgEl: SVGSVGElement) => {\n    let src =\n        'https://fonts.googleapis.com/css?family=Noto+Serif+KR:600|Noto+Serif+JP:600|Noto+Serif+TC:600|Noto+Serif+SC:600%26display=swap';\n    return fetch(src)\n        .then(response => response.text())\n        .then(async csstext => {\n            let s = document.createElement('style');\n            s.type = 'text/css';\n            s.id = 'googlefonts';\n            s.innerText = csstext;\n            document.head.append(s);\n\n            let txt = Array.from(\n                new Set(\n                    Array.from(svgEl.querySelectorAll('.rmg-name__zh') as NodeListOf<SVGTextElement | SVGTSpanElement>)\n                        .map(el => el.innerHTML)\n                        .join('')\n                        .replace(/[\\d\\s]/g, '')\n                )\n            );\n\n            return Promise.all(txt.map(getRenderedFontFace))\n                .then(rules => ([] as string[]).concat(...rules))\n                .then(rules => [...new Set(rules)])\n                .then(rules => {\n                    return rules.map(async rule => {\n                        return fetch(rule.match(/https:[\\w:/.-]+.woff2/g)![0])\n                            .then(response => response.blob())\n                            .then(readBlobAsDataURL)\n                            .then(uri => rule.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${uri}'); `));\n                    });\n                });\n        });\n};\n"],"sourceRoot":""}